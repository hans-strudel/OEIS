{"formerly":"","seq":"1,1,1,1,2,1,1,4,4,1,1,5,8,5,1,1,7,13,13,7,1,1,8,20,26,20,8,1,1,10,28,46,46,28,10,1,1,11,38,74,92,74,38,11,1,1,13,49,112,166,166,112,49,13,1,1,14,62,161,278,332,278,161,62,14,1,1,16,76","description":"Triangular array T read by rows: T(n,0)=T(n,n)=1 for n >= 0; T(n,1)=T(n,n-1)=[ (3n-1)/2 ] for n >= 1; T(n,k)=T(n-1,k-1)+T(n-1,k) for 2<=k<=n-2, n >= 4.","comments":"See A228053 for a sequence with many terms in common with this one. - _T. D. Noe_, Aug 07 2013","links":["Reinhard Zumkeller, <a href=\"/A026637/b026637.txt\">Rows n = 0..100 of table, flattened</a>"],"formula":"T(n, k) = number of paths from (0, 0) to (n-k, k) in directed graph having vertices (i, j) and edges (i, j)-to-(i+1, j) and (i, j)-to-(i, j+1) for i, j >= 0 and edges (i, j)-to-(i+1, j+1) for i=0, j >= 1 and odd and for j=0, i >= 1 and odd.","example":"1;1,1;1,2,1;1,4,4,1;1,5,8,5,1;1,7,13,13,7,1;1,8,20,26,20,8,1;1,10,28,46,46,28,10,1;1,11,38,74,92,74,38,11,1;1,13,49,112,166,166,112,49,13,1;1,14,62,161,278,332,278,161,62,14,1;","maple":"A026637 := proc(n,k)      option remember;      if k=0 or k=n then        1    elif k=1 or k=n-1 then        floor((3*n-1)/2) ;    elif k <0 or k > n then        0;    else        procname(n-1,k-1)+procname(n-1,k) ;    end if;end proc: # _R. J. Mathar_, Apr 26 2015","prog":"(Haskell)a026637 n k = a026637_tabl !! n !! ka026637_row n = a026637_tabl !! na026637_tabl = [1] : [1,1] : map (fst . snd)   (iterate f (0, ([1,2,1], [0,1,1,0]))) where   f (i, (xs, ws)) = (1 - i,     if i == 1 then (ys, ws) else (zipWith (+) ys ws, ws'))        where ys = zipWith (+) ([0] ++ xs) (xs ++ [0])              ws' = [0,1,0,0] ++ drop 2 ws-- _Reinhard Zumkeller_, Aug 08 2013","keyword":"nonn,tabl,easy","offset":"0,5","author":"_Clark Kimberling_"}