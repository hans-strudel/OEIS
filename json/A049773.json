{"formerly":"","seq":"1,1,2,1,3,2,4,1,5,3,7,2,6,4,8,1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16,1,17,9,25,5,21,13,29,3,19,11,27,7,23,15,31,2,18,10,26,6,22,14,30,4,20,12,28,8,24,16,32,1,33,17,49,9,41,25,57,5,37,21,53,13,45,29,61,3,35,19","description":"Triangular array T read by rows: if row n is r(1),...,r(m), then row n+1 is 2r(1)-1,...,2r(m)-1,2r(1),...,2r(m).","comments":"n-th row = (r(1),r(2),...,r(m)), where m=2^(n-1), satisfies r(r(k))=k for k=1,2,...,m and has exactly 2^[ n/2 ] solutions of r(k)=k. (The function r(k) reverses bits. Or rather, r(k)=revbits(k-1)+1.In a knockout competition with m players, arranging the competition brackets (see links) in r(k) order, where k is the rank of the player, ensures that highest ranked players cannot meet until the later stages of the competition.  None of the top 2^p ranked players can meet earlier than the p-th from last round of the competition.  At the same time the top ranked players in each match meet the highest ranked player possible consistent with this rule.  The sequence for the top ranked players meeting the lowest ranked player possible is A208569.  See also A131271. - _Colin Hall_, Jul 31 2011, Feb 29 2012","links":["Alois P. Heinz, <a href=\"/A049773/b049773.txt\">Rows n = 1..13, flattened</a>","Wikipedia, <a href=\"http://en.wikipedia.org/wiki/Bracket_%28tournament%29\">Bracket (tournament)</a>"],"example":"Rows: {1}; {1,2}; {1,3,2,4}; {1,5,3,7,2,6,4,8}; ...","maple":"T:= proc(n) option remember; `if`(n=1, 1,      [map(x->2*x-1, [T(n-1)])[], map(x->2*x, [T(n-1)])[]][])    end:seq(T(n), n=1..7);  # _Alois P. Heinz_, Oct 28 2011","mathematica":"row[1] = {1}; row[n_] := row[n] = Join[ 2*row[n-1] - 1, 2*row[n-1] ]; Flatten[ Table[ row[n], {n, 1, 7}]] (* _Jean-Fran√ßois Alcover_, May 03 2012 *)","prog":"(PARI) (a(n, k) = if( k<=0 || k>=n, 0, if( k%2, n\\2) + a(n\\2, k\\2))); {T(n, k) = if( k<=0 || k>2^n/2, 0, 1 + a(2^n/2, k-1))}; /* _Michael Somos_, Oct 13 1999 */(Haskell)a049773 n k = a049773_tabf !! (n-1) !! (k-1)a049773_row n = a049773_tabf !! (n-1)a049773_tabf = iterate f [1] where   f vs = (map (subtract 1) ws) ++ ws where ws = map (* 2) vs-- _Reinhard Zumkeller_, Mar 14 2015","crossrefs":["Sum of odd-indexed terms of n-th row gives A007582. Sum of even-indexed terms gives A049775.","A030109 is another version.","A131271.","Cf. A088370. - _Alois P. Heinz_, Oct 28 2011","Cf. A208569. - _Colin Hall_, Feb 29 2012","Cf. A088208."],"keyword":"nonn,tabf,nice,look","offset":"1,3","author":"_Clark Kimberling_"}