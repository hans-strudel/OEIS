{"formerly":"","seq":"0,1,3,3,5,5,9,7,9,9,15,27,15,27,21,15,17,17,27,99,99,21,1,63,27,99,1,27,1,63,45,31,33,33,51,1,45,1,63,99,45,1,63,99,99,45,1,1,51,1,255,51,63,99,255,153,63,99,255,153,1,1,93,63,65,65,99,1,85,255,119,387,255,73,13299,1,387,1,1,219,850,1,3,3,5,5,9,7,9,9,15,27,15,27,21,15,17,17,27,99,99,21,-1,63,27,99,-1,27,-1,63,45,31,33,33,51,-1,45,-1,63,99,45,-1,63,99,99,45,-1,-1,51,-1,255,51,63,99,255,153,63,99,255,153,-1,-1,93,63,65,65,99,-1,85,255,119,387,255,73,13299,-1,387,-1,-1,219,85","description":"A062128 written in base 10.","links":["<a href=\"/index/Res#RAA\">Index entries for sequences related to Reverse and Add!</a>","Klaus Brockhaus, <a href=\"/A058042/a058042.txt\">On the'Reverse and Add!' algorithm in base 2</a>"],"example":"23 -> 23 + 29 = 52 -> 52 + 11 = 63, so a(23) = 63.","prog":"(ARIBAS): stop := 500; for k := 0 to 80 do c := 0; m := k; rev := bit_reverse(m); while m <> rev and c < stop do inc(c); m := m + rev; rev := bit_reverse(m); end; if c < stop then write(m); else write(-1); end; write(\" \"); end;.","crossrefs":["A033865, A062128, A062131, A061561."],"keyword":"base,easy,sign","offset":"0,3","author":"_Klaus Brockhaus_, Jun 06 2001"}