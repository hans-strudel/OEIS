{"formerly":"","seq":"1,1,1,1,1,1,1,1,1,1,1,7,5,4,4,3,3,3,3,1,11,1,4,7,3,5,2,4,2,1,11,6,1,3,3,7,2,2,5,1,11,11,4,1,3,4,2,7,2,1,11,6,4,3,1,2,2,2,2,1,11,11,11,6,3,1,2,3,4,1,11,6,4,3,3,2,1,2,2,1,11,11,4,11,3,4,2,1,2,1,11,6,11,3,3,6,2,2","description":"Number of partitions of n into parts which are the digits of n.","comments":"a(A125289(n)) = 1,  a(A125290(n)) > 1.","links":["Reinhard Zumkeller and Alois P. Heinz, <a href=\"/A061827/b061827.txt\">Table of n, a(n) for n = 1..15000</a> [Terms 1 through 1250 were computed by _Reinhard Zumkeller_, terms 1251 through 15000 by _Alois P. Heinz_]"],"example":"For n = 11, 1+1+1+1+1+1+1+1+1+1+1. so a(11) = 1. For n = 12, 2+2+2+2+2+2 = 2+2+1+1+1+1+1+1+1+1 = ...etca(20) = 1: the only partitions permitted use the digits 0 and 2, so there is just 1, 20 = 2+2+2... ten times.","prog":"(Haskell)import Data.List (sort, nub)import Data.Char (digitToInt)a061827 n =   p n (map digitToInt $ nub $ sort $ filter (/= '0') $ show n) where      p _ []        = 0      p 0 _         = 1      p m ds'@(d:ds)        | m < d     = 0        | otherwise = p (m - d) ds' + p m ds-- _Reinhard Zumkeller_, Aug 01 2011","crossrefs":["Cf. A061828, A109950, A119999, A125291, A136460, A193513."],"keyword":"nonn,base,easy,look","offset":"1,12","author":"_Amarnath Murthy_, May 28 2001","extensions":["More terms from _David Wasserman_, Jul 29 2002"]}