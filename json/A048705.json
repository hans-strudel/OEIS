{"formerly":"","seq":"90,150,1721342310,140117185019831836588493434554119984790,113427455640312821160607117168492587690","description":"The rule numbers for 1-D CA composed of Rules \"90\" and \"150\" so that each direction occurs only once.","comments":"The \"numerator\" (0, 1 and the rest from A020652) is the multiplicity of the \"Rule 150\" component and the \"denominator\" (1, 0 and the rest from A020653) is the multiplicity of the \"Rule 90\" component.The resulting numbers define one-dimensional linear cellular automata with radius being the sum of the amount of the \"90\" and \"150\" components.In hexadecimal the sequence is 5A, 96, 66999966, 69699696969669699696696969699696, 5555555555555555AAAAAAAAAAAAAAAA, ...","links":["<a href=\"/index/Ce#cell\">Index entries for sequences related to cellular automata</a>"],"formula":"a(n) = rule90x150combination(n) # See the Maple procedures below.","maple":"# The definitions of bit_i and floor_log_2 are given in A048700rule90 := proc(seed,n) option remember: local sl, i: if (0 = n) then (seed) else sl := floor_log_2(seed+1); add(((bit_i(rule90(seed,n-1),i)+bit_i(rule90(seed,n-1),i-2)) mod 2)*(2^i), i=0..(2*n)+sl) fi: end:rule150 := proc(seed,n) option remember: local sl, i: if (0 = n) then (seed) else sl := floor_log_2(seed+1);add(((bit_i(rule150(seed,n-1),i)+bit_i(rule150(seed,n-1),i-1)+bit_i(rule150(seed,n-1),i-2)) mod 2)*(2^i), i=0..((2*n)+sl)) fi: end:# Rule 90 and Rule 150 are commutative in respect to each other:rule90x150combination := proc(n) local p,q,i; p := extended_A020652[ n ]; # the Rule 150 component [ 0,1,op(A020652) ]q := extended_A020653[ n ]; # the Rule 90 component [ 1,0,op(A020653) ]RETURN(sum('bit_i(rule150(rule90(i,q),p),(2*(p+q))) * (2^i)','i'=0..(2^((2*(p+q))+1))-1));end:","crossrefs":["A048706 gives the corresponding \"XOR-conjugate\" rules.","Cf. A038183, A038184, A048709 (for specific examples). See also A048708, A048720."],"keyword":"nonn","offset":"1,1","author":"_Antti Karttunen_, Mar 09 1999"}